#!/usr/bin/env python3
"""
Extractor v5.4 - CSV EXCEL-PERFECTO (sin comas en nombres)
"""

import argparse
import re
import pandas as pd
from pathlib import Path
import sys
from typing import Dict, Optional
from datetime import datetime
import csv

try:
    import fitz
    PYMUPDF_AVAILABLE = True
except ImportError:
    PYMUPDF_AVAILABLE = False

def limpiar_campo_csv(texto: str) -> str:
    """Elimina comas y caracteres problem√°ticos para CSV"""
    if not texto:
        return ""
    # Quitar comas, punto y coma, comillas dobles
    texto = re.sub(r'[,;"‚Ç¨\n\r]', ' ', texto)
    # Limitar longitud
    return texto.strip()[:50]

def limpiar_texto_inicial(texto: str) -> str:
    """Descartar ANTES de \\n?"""
    patron_inicio = r'\\n\?|\\n|\n\?'
    match = re.search(patron_inicio, texto)
    if match:
        return texto[match.end():].strip()
    return texto.strip()

def extraer_texto_completo(pdf_path: Path) -> str:
    if not PYMUPDF_AVAILABLE: return ""
    try:
        doc = fitz.open(pdf_path)
        texto = ""
        for page in doc:
            texto += page.get_text() + "\n"
        doc.close()
        return limpiar_texto_inicial(texto)
    except:
        return ""

def normalizar_numero(numero: str) -> str:
    return re.sub(r'[^\w\-]', '', str(numero).strip())[:20] if numero else ""

def normalizar_fecha(fecha: str) -> str:
    if not fecha: return ""
    fecha = re.sub(r'[^\d/.-]', '', fecha)[:10]
    return fecha

def normalizar_importe(importe: str) -> Optional[float]:
    if not importe: return None
    importe = re.sub(r'[‚Ç¨EUR\s‚Ç¨]', '', str(importe).strip())
    importe = re.sub(r'[^\d.,]', '', importe.replace(',', '.'))
    try: return float(importe)
    except: return None

def extraer_proveedor_por_SL(texto: str) -> str:
    """Texto ANTES de SL/SLU"""
    patrones_SL = [
        r'([A-Z√Å√â√ç√ë√ì√ö][a-z√°√©√≠√±√≥√∫]+(?:\s+[A-Z√Å√â√ç√ë√ì√ö][a-z√°√©√≠√±√≥√∫]+)*?)\s*[.,]?\s*(?:S\.?L\.?(?:\.?U\.?)?)',
        r'([A-Z√Å√â√ç√ë√ì√ö][a-z√°√©√≠√±√≥√∫]+(?:\s+[A-Z√Å√â√ç√ë√ì√ö][a-z√°√©√≠√±√≥√∫]+)*?)\s+(?:S\.?L\.?(?:\.?U\.?)?)',
    ]
    for patron in patrones_SL:
        match = re.search(patron, texto, re.IGNORECASE)
        if match:
            return limpiar_campo_csv(match.group(1).strip())
    return ""

def extraer_proveedor_cliente_por_bloques(texto: str, nombre_cliente: str) -> Dict[str, str]:
    # SL/SLU PRIORIDAD
    proveedor_sl = extraer_proveedor_por_SL(texto)
    if proveedor_sl:
        return {
            "cliente": limpiar_campo_csv(nombre_cliente),
            "proveedor": proveedor_sl
        }
    
    # NIF Fallback
    nif_match = re.search(r'(?:CIF|NIF)\s*[:\-]?\s*([A-Z]\d{8}[A-Z0-9]?)', texto, re.IGNORECASE)
    if nif_match:
        return {
            "cliente": limpiar_campo_csv(nombre_cliente),
            "proveedor": limpiar_campo_csv(nif_match.group(1))
        }
    
    return {
        "cliente": limpiar_campo_csv(nombre_cliente),
        "proveedor": "Proveedor no detectado"
    }

def extraer_importes_universal(texto: str) -> Dict[str, Optional[float]]:
    zona_resumen = texto[-3000:]
    patrones = [
        (r'(?:Total\s*(?:factura|a pagar|final|en EUR)?|TOTAL|Importe total)\s*[:\-\(\)]*\s*([\d.,]+)', 'total'),
        (r'(?:Base\s*(?:imponible|imp\.?)|Subtotal|IMPORTE\s*\(base imponible\))\s*[:\-\(\)]*\s*([\d.,]+)', 'base_imponible'),
        (r'(?:IVA?|I\.V\.A\.?|IMPUESTOS\s*\(21)\s*[:\-\(\)]*\s*([\d.,]+)', 'iva'),
    ]
    
    resultado = {'total': None, 'base_imponible': None, 'iva': None}
    for patron, campo in patrones:
        if resultado[campo] is not None: continue
        match = re.search(patron, zona_resumen, re.IGNORECASE | re.DOTALL)
        if match:
            valor = normalizar_importe(match.group(1))
            if valor: resultado[campo] = valor
    return resultado

def extraer_datos_factura_completo(texto: str, nombre_fichero: str, nombre_cliente: str) -> Dict:
    datos = {
        'numero_factura': '', 'fecha_factura': '', 'proveedor': '', 'cliente': '',
        'base_imponible': None, 'iva': None, 'total': None, 'nombre_fichero': nombre_fichero
    }
    
    # N√∫mero
    numero_match = (re.search(r'N(?:\.¬∞|¬∫)?\s*de?\s*factura\s*[:\-]?\s*(\w+)', texto) or 
                    re.search(r'N√∫mero\s*[:\-]?\s*(\w+)', texto))
    datos['numero_factura'] = normalizar_numero(numero_match.group(1)) if numero_match else Path(nombre_fichero).stem
    
    # Fecha
    fecha_match = re.search(r'Fecha\s+de?\s*(?:factura|facturaci√≥n|emisi√≥n)\s*[:\-]?\s*([\d/\.-]{8,10})', texto, re.IGNORECASE)
    if not fecha_match:
        fecha_match = re.search(r'\b(\d{1,2}[/\.-]\d{1,2}[/\.-]\d{2,4})\b', texto)
    datos['fecha_factura'] = normalizar_fecha(fecha_match.group(1)) if fecha_match else ""
    
    # Importes
    importes = extraer_importes_universal(texto)
    datos.update(importes)
    
    # Proveedor + Cliente LIMPIOS
    contacto = extraer_proveedor_cliente_por_bloques(texto, nombre_cliente)
    datos['cliente'] = contacto['cliente']
    datos['proveedor'] = contacto['proveedor']
    
    # LIMPIAR TODOS los campos para CSV
    for campo in ['numero_factura', 'fecha_factura', 'proveedor', 'cliente', 'nombre_fichero']:
        datos[campo] = limpiar_campo_csv(datos[campo])
    
    return datos

def guardar_csv_perfecto(df: pd.DataFrame, output_file: str):
    """CSV 100% compatible Excel"""
    # Convertir None/float a string seguro
    for col in df.select_dtypes(include=['float']).columns:
        df[col] = df[col].apply(lambda x: f"{x:.2f}" if pd.notna(x) else "")
    
    # Escribir CSV con quoting OBLIGATORIO
    df.to_csv(output_file, index=False, encoding='utf-8-sig', 
              quoting=csv.QUOTE_ALL, sep=',')
    print(f"üíæ CSV perfecto guardado: {output_file}")

def main():
    parser = argparse.ArgumentParser(description='Extractor v5.4 - CSV EXCEL-PERFECTO')
    parser.add_argument('carpeta_pdf', help='Carpeta PDFs')
    parser.add_argument('-o', '--output', help='CSV salida')
    args = parser.parse_args()
    
    carpeta = Path(args.carpeta_pdf)
    if not carpeta.exists():
        print(f"‚ùå Carpeta no existe: {carpeta}")
        sys.exit(1)
    
    # Input cliente
    try:
        print("üë§ CLIENTE")
        nombre_cliente = input("Nombre tal como aparece en factura: ").strip()
    except KeyboardInterrupt:
        print("\nüëã Cancelado")
        sys.exit(0)
    
    print(f"\nüöÄ v5.4 - Cliente: '{nombre_cliente}'")
    
    filas, procesados = [], 0
    
    for pdf_path in carpeta.glob("*.pdf"):
        print(f"\nüìÑ {pdf_path.name}")
        procesados += 1
        
        texto = extraer_texto_completo(pdf_path)
        if not texto.strip():
            print("   ‚ùå SIN TEXTO")
            continue
        
        datos = extraer_datos_factura_completo(texto, pdf_path.name, nombre_cliente)
        filas.append(datos)
        
        total_str = f"{datos.get('total', 0):.2f}" if datos.get('total') is not None else "N/D"
        print(f"   ‚úÖ Total: ‚Ç¨{total_str} | Proveedor: {datos.get('proveedor', 'N/D')}")
    
    if not filas:
        print("‚ùå Sin PDFs v√°lidos")
        sys.exit(1)
    
    df = pd.DataFrame(filas)
    columnas = ['numero_factura', 'fecha_factura', 'proveedor', 'cliente', 
                'base_imponible', 'iva', 'total', 'nombre_fichero']
    df = df[columnas]
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = args.output or f"facturas_v54_perfecto_{timestamp}.csv"
    
    guardar_csv_perfecto(df, output_file)
    
    print(f"\nüéâ ¬°CSV PERFECTO para Excel!")
    print(f"üìä {len(filas)}/{procesados} procesados")
    print(f"üìà Totales detectados: {df['total'].str.replace('', '0', regex=False).astype(float).gt(0).sum()}/{len(df)}")
    
    print("\nüìã COLUMNA A COLUMNA:")
    print(df[columnas].to_string(index=False, max_colwidth=20))

if __name__ == "__main__":
    sys.exit(main())
